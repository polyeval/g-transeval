int SumDigits ( int no ) { return no == 0 ? 0 : no % 10 + SumDigits ( no / 10 ) ; }
int FindSum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) ans += ( i / j ) ; return ans ; }
bool IsPalindrome ( string s ) { int l = s . length ( ) ; int j ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; }
int GetMinStepToReachEnd ( int arr [ ] , int n ) { bool visit [ n ] ; int distance [ n ] ; vector < int > digit [ 10 ] ; memset ( visit , false , sizeof ( visit ) ) ; for ( int i = 1 ; i < n ; i ++ ) digit [ arr [ i ] ] . push_back ( i ) ; distance [ 0 ] = 0 ; visit [ 0 ] = true ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int idx = q . front ( ) ; q . pop ( ) ; if ( idx == n - 1 ) break ; int d = arr [ idx ] ; for ( int i = 0 ; i < digit [ d ] . size ( ) ; i ++ ) { int nextidx = digit [ d ] [ i ] ; if ( ! visit [ nextidx ] ) { visit [ nextidx ] = true ; q . push ( nextidx ) ; distance [ nextidx ] = distance [ idx ] + 1 ; } } digit [ d ] . clear ( ) ; if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) { visit [ idx - 1 ] = true ; q . push ( idx - 1 ) ; distance [ idx - 1 ] = distance [ idx ] + 1 ; } if ( idx + 1 < n && ! visit [ idx + 1 ] ) { visit [ idx + 1 ] = true ; q . push ( idx + 1 ) ; distance [ idx + 1 ] = distance [ idx ] + 1 ; } } return distance [ n - 1 ] ; }
long FindWays ( int f , int d , int s ) { long mem [ d + 1 ] [ s + 1 ] ; memset ( mem , 0 , sizeof mem ) ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
int MaxVolume ( int s ) { int max_value = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; max_value = max ( max_value , i * j * k ) ; } } return max_value ; }
int MinDaysToEmpty ( int c , int l ) { if ( l >= c ) return c ; double eq_root = ( std :: sqrt ( 1 + 8 * ( c - l ) ) - 1 ) / 2 ; return std :: ceil ( eq_root ) + l ; }
int MinDiff ( int arr [ ] , int n , int k ) { int result = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
void Concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) c [ i ] = a [ i ] ; for ( int j = 0 ; j < n2 ; j ++ ) c [ i ++ ] = b [ j ] ; c [ i ] = ' \0' ; }
int CeilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
void PrintMaxSubSquare ( bool m [ R ] [ C ] ) { int i , j ; int s [ R ] [ C ] ; int max_of_s , max_i , max_j ; for ( i = 0 ; i < R ; i ++ ) s [ i ] [ 0 ] = m [ i ] [ 0 ] ; for ( j = 0 ; j < C ; j ++ ) s [ 0 ] [ j ] = m [ 0 ] [ j ] ; for ( i = 1 ; i < R ; i ++ ) { for ( j = 1 ; j < C ; j ++ ) { if ( m [ i ] [ j ] == 1 ) s [ i ] [ j ] = min ( s [ i ] [ j - 1 ] , min ( s [ i - 1 ] [ j ] , s [ i - 1 ] [ j - 1 ] ) ) + 1 ; else s [ i ] [ j ] = 0 ; } } max_of_s = s [ 0 ] [ 0 ] ; max_i = 0 ; max_j = 0 ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( max_of_s < s [ i ] [ j ] ) { max_of_s = s [ i ] [ j ] ; max_i = i ; max_j = j ; } } } cout << " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ \n " ; for ( i = max_i ; i > max_i - max_of_s ; i -- ) { for ( j = max_j ; j > max_j - max_of_s ; j -- ) { cout << m [ i ] [ j ] << " ▁ " ; } cout << " \n " ; } }
int MinMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }
bool IsComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
void FindMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { sort ( arrl , arrl + n ) ; sort ( exit , exit + n ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } cout << " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " << max_guests << " ▁ at ▁ time ▁ " << time ; }
int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) cout << 1 << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } return 0 ; }
int PrintKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
void Reorder ( int arr [ ] , int index [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
int PrintCountDP ( int dist ) { int count [ dist + 1 ] ; count [ 0 ] = 1 , count [ 1 ] = 1 , count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
int MaximumChars ( string & str ) { int n = str . length ( ) ; int res = - 1 ; int first_inds [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) first_inds [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = first_inds [ str [ i ] ] ; if ( first_ind == - 1 ) first_inds [ str [ i ] ] = i ; else res = max ( res , abs ( i - first_ind - 1 ) ) ; } return res ; }
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
int FindMaxProduct ( int arr [ ] , int n ) { int i ; int ans = INT_MIN ; int max_val = 1 ; int min_val = 1 ; int prev_max ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { max_val = max_val * arr [ i ] ; min_val = min ( 1 , min_val * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { min_val = 1 ; max_val = 0 ; } else if ( arr [ i ] < 0 ) { prev_max = max_val ; max_val = min_val * arr [ i ] ; min_val = prev_max * arr [ i ] ; } ans = max ( ans , max_val ) ; if ( max_val <= 0 ) { max_val = 1 ; } } return ans ; }
void Survival ( int s , int n , int m ) { if ( ( ( n * 6 ) < ( m * 7 ) && s > 6 ) || m > n ) cout << " No \n " ; else { int days = ( m * s ) / n ; if ( ( ( m * s ) % n ) != 0 ) days ++ ; cout << " Yes ▁ " << days << endl ; } }
void FirstNonRepeating ( char str [ ] ) { queue < char > q ; int char_count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) { q . push ( str [ i ] ) ; char_count [ str [ i ] - ' a ' ] ++ ; while ( ! q . empty ( ) ) { if ( char_count [ q . front ( ) - ' a ' ] > 1 ) q . pop ( ) ; else { cout << q . front ( ) << " ▁ " ; break ; } } if ( q . empty ( ) ) cout << - 1 << " ▁ " ; } cout << endl ; }
void Dfs ( vector < int > list [ ] , int node , int arrival ) { cout << node << ' \n ' ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] [ i ] != arrival ) Dfs ( list , list [ node ] [ i ] , node ) ; } }
int FindRepeating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ] ; res = res ^ arr [ n - 1 ] ; return res ; }
int GetCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL || n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int odd [ 10 ] , even [ 10 ] ; int i = 0 , j = 0 , use_odd = 0 , total_count = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { use_odd = 1 - use_odd ; if ( use_odd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } total_count = 0 ; if ( use_odd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) total_count += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) total_count += odd [ i ] ; } return total_count ; }
int CountSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { map < int , int > mp ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; sum += arr [ i ] ; if ( sum == 0 ) count ++ ; if ( mp [ sum ] ) count += mp [ sum ] ; if ( mp [ sum ] == 0 ) mp [ sum ] = 1 ; else mp [ sum ] ++ ; } return count ; }
void Search ( int mat [ ROW ] [ COL ] , int from_row , int to_row , int from_col , int to_col , int key ) { int i = from_row + ( to_row - from_row ) / 2 ; int j = from_col + ( to_col - from_col ) / 2 ; if ( mat [ i ] [ j ] == key ) cout << " Found ▁ " << key << " ▁ at ▁ " << i << " ▁ " << j << endl ; else { if ( i != to_row || j != from_col ) Search ( mat , from_row , i , j , to_col , key ) ; if ( from_row == to_row && from_col + 1 == to_col ) if ( mat [ from_row ] [ to_col ] == key ) cout << " Found ▁ " << key << " ▁ at ▁ " << from_row << " ▁ " << to_col << endl ; if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= to_row ) Search ( mat , i + 1 , to_row , from_col , to_col , key ) ; } else { if ( j - 1 >= from_col ) Search ( mat , from_row , to_row , from_col , j - 1 , key ) ; } } }
int KthGroupSum ( int k ) { return k * k * k ; }
bool AreKAnagrams ( string str1 , string str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int hash_str1 [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 [ i ] - ' a ' ] > 0 ) hash_str1 [ str2 [ i ] - ' a ' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
void BonacciSeries ( long n , int m ) { int a [ m ] = { 0 } ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) for ( int j = i - n ; j < i ; j ++ ) a [ i ] += a [ j ] ; for ( int i = 0 ; i < m ; i ++ ) cout << a [ i ] << " ▁ ▁ " ; }
void PrintMinIndexChar ( string str , string patt ) { int min_index = INT_MAX ; int m = str . size ( ) ; int n = patt . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt [ i ] == str [ j ] && j < min_index ) { min_index = j ; break ; } } } if ( min_index != INT_MAX ) cout << " Minimum ▁ Index ▁ Character ▁ = ▁ " << str [ min_index ] ; else cout << " No ▁ character ▁ present " ; }
bool NegCycleFloydWarshall ( int graph [ ] [ V ] ) { int dist [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ; for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } for ( int i = 0 ; i < V ; i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ; return false ; }
string LexNext ( string s , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return s ; } s [ i ] = ' a ' ; } }
void PrintDuo ( string & str ) { int count_char [ MAX_CHAR ] = { 0 } ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) count_char [ str [ i ] - ' a ' ] ++ ; string str1 = " " , str2 = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count_char [ i ] > 1 ) str2 = str2 + ( char ) ( i + ' a ' ) ; else if ( count_char [ i ] == 1 ) str1 = str1 + ( char ) ( i + ' a ' ) ; } cout << " String ▁ with ▁ characters ▁ occurring ▁ " << " once : \n " ; cout << str1 << " \n " ; cout << " String ▁ with ▁ characters ▁ occurring ▁ " << " multiple ▁ times : \n " ; cout << str2 << " \n " ; }
void RoundOff ( double n , double n1 ) { int h ; double l , a , b , c , d , e , i , j , m , f , g ; b = n ; c = floor ( n ) ; for ( i = 0 ; b >= 1 ; ++ i ) b = b / 10 ; d = n1 - i ; b = n ; b = b * pow ( 10 , d ) ; e = b + 0.5 ; if ( ( float ) e == ( float ) ceil ( b ) ) { f = ( ceil ( b ) ) ; h = f - 2 ; if ( h % 2 != 0 ) { e = e - 1 ; } } j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; cout << " The ▁ number ▁ after ▁ rounding - off ▁ is ▁ " << j ; }
void PrintRotatedString ( char str [ ] ) { int len = strlen ( str ) ; char temp [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { int j = i ; int k = 0 ; while ( str [ j ] != ' \0' ) { temp [ k ] = str [ j ] ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { temp [ k ] = str [ j ] ; j ++ ; k ++ ; } printf ( " % s \n " , temp ) ; } }
int Difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return abs ( d1 - d2 ) ; }
int Calculate ( string n ) { int len = n . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { string s = n . substr ( 0 , i ) ; int l1 = s . length ( ) ; string t = n . substr ( i , l1 ) ; if ( s [ 0 ] == '0' || t [ 0 ] == '0' ) continue ; if ( s . compare ( t ) == 0 ) count ++ ; } return count ; }
int PrintUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) cout << arr1 [ i ++ ] << " ▁ " ; else if ( arr2 [ j ] < arr1 [ i ] ) cout << arr2 [ j ++ ] << " ▁ " ; else { cout << arr2 [ j ++ ] << " ▁ " ; i ++ ; } } while ( i < m ) cout << arr1 [ i ++ ] << " ▁ " ; while ( j < n ) cout << arr2 [ j ++ ] << " ▁ " ; }
void PrintDistinct ( string str ) { int n = str . length ( ) ; int count [ MAX_CHAR ] ; int index [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str [ i ] ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ▁ ' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } sort ( index , index + MAX_CHAR ) ; for ( int i = 0 ; i < MAX_CHAR && index [ i ] != n ; i ++ ) cout << str [ index [ i ] ] ; }
int FindCommon ( int mat [ M ] [ N ] ) { int column [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return - 1 ; }
double PolygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return abs ( area / 2.0 ) ; }
int MaxProfit ( int price [ ] , int n , int k ) { int profit [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_so_far = INT_MIN ; for ( int m = 0 ; m < j ; m ++ ) max_so_far = max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) ; profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , max_so_far ) ; } } return profit [ k ] [ n - 1 ] ; }
bool Match ( string first , string second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) > 1 && first [ 0 ] == ' * ' && second . length ( ) == 0 ) return false ; if ( * first == ' ? ' || * first == * second ) return match ( first + 1 , second + 1 ) ; if ( * first == ' * ' ) return match ( first + 1 , second ) || match ( first , second + 1 ) ; return false ; }
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
bool isPermutedMatrix ( int mat [ MAX ] [ MAX ] , int n ) { string str_cat = " " ; for ( int i = 0 ; i < n ; i ++ ) str_cat = str_cat + " - " + to_string ( mat [ 0 ] [ i ] ) ; str_cat = str_cat + str_cat ; for ( int i = 1 ; i < n ; i ++ ) { string curr_str = " " ; for ( int j = 0 ; j < n ; j ++ ) curr_str = curr_str + " - " + to_string ( mat [ i ] [ j ] ) ; if ( str_cat . find ( curr_str ) == string :: npos ) return false ; } return true ; }
bool isSparse ( int array [ ] [ MAX ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; }
float findArea ( float r ) { return ( pi * r * r ) ; }
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
void counterClockspiralPrint ( int m , int n , int arr [ R ] [ C ] ) { int i , k = 0 , l = 0 ; int cnt = 0 ; int total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) break ; for ( i = k ; i < m ; ++ i ) { cout << arr [ i ] [ l ] << " ▁ " ; cnt ++ ; } l ++ ; if ( cnt == total ) break ; for ( i = l ; i < n ; ++ i ) { cout << arr [ m - 1 ] [ i ] << " ▁ " ; cnt ++ ; } m -- ; if ( cnt == total ) break ; if ( k < m ) { for ( i = m - 1 ; i >= k ; -- i ) { cout << arr [ i ] [ n - 1 ] << " ▁ " ; cnt ++ ; } n -- ; } if ( cnt == total ) break ; if ( l < n ) { for ( i = n - 1 ; i >= l ; -- i ) { cout << arr [ k ] [ i ] << " ▁ " ; cnt ++ ; } k ++ ; } } }
int numberOfTriangles ( int n ) { int ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { sort ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; cout << time ; }
void countToMake0lternate ( const string & s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) result ++ ; return result ; }
int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int compute_average ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }
int countSubStr ( char str [ ] ) { int res = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; str [ j ] != ' \0' ; j ++ ) if ( str [ j ] == '1' ) res ++ ; } } return res ; }
bool isDivisibleBy10 ( string bin ) { int n = bin . size ( ) ; if ( bin [ n - 1 ] == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; }
void search ( int * arr , int low , int high ) { if ( low > high ) return ; if ( low == high ) { printf ( " The ▁ required ▁ element ▁ is ▁ % d ▁ " , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; sort ( A , A + arr_size ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { printf ( " Triplet ▁ is ▁ % d , ▁ % d , ▁ % d " , A [ i ] , A [ l ] , A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }
void makePermutation ( int a [ ] , int n ) { unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ a [ i ] ] != 1 || a [ i ] > n || a [ i ] < 1 ) { count [ a [ i ] ] -- ; while ( count . find ( next_missing ) != count . end ( ) ) next_missing ++ ; a [ i ] = next_missing ; count [ next_missing ] = 1 ; } } }
int optimalStrategyOfGame ( int * arr , int n ) { int table [ n ] [ n ] ; for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { int x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
unsigned long long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
void interchangeFirstLast ( int m [ ] [ n ] ) { int rows = n ; for ( int i = 0 ; i < n ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
void maxOverlap ( vector < int > & start , vector < int > & end ) { int n = start . size ( ) ; int maxa = * max_element ( start . begin ( ) , start . end ( ) ) ; int maxb = * max_element ( end . begin ( ) , end . end ( ) ) ; int maxc = max ( maxa , maxb ) ; int x [ maxc + 2 ] ; memset ( x , 0 , sizeof x ) ; int cur = 0 , idx ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = INT_MIN ; for ( int i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } cout << " Maximum ▁ value ▁ is ▁ " << maxy << " ▁ at ▁ position ▁ " << idx << endl ; }
bool canFormPalindrome ( string str ) { vector < char > list ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { auto pos = find ( list . begin ( ) , list . end ( ) , str [ i ] ) ; if ( pos != list . end ( ) ) { auto posi = find ( list . begin ( ) , list . end ( ) , str [ i ] ) ; list . erase ( posi ) ; } else list . push_back ( str [ i ] ) ; } if ( str . length ( ) % 2 == 0 && list . empty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true ; else return false ; }
int fib ( int n , int a = 0 , int b = 1 ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; return fib ( n - 1 , b , a + b ) ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; }
void kmax ( int arr [ ] , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int max_so_far = numeric_limits < int > :: min ( ) ; int max_here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) { max_so_far = max_here ; start = s ; end = i ; } if ( max_here < 0 ) { max_here = 0 ; s = i + 1 ; } } cout << " Maximum ▁ non - overlapping ▁ sub - array ▁ sum " << ( c + 1 ) << " : ▁ " << max_so_far << " , ▁ starting ▁ index : ▁ " << start << " , ▁ ending ▁ index : ▁ " << end << " . " << endl ; for ( int l = start ; l <= end ; l ++ ) arr [ l ] = numeric_limits < int > :: min ( ) ; } cout << endl ; }
int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; sort ( X , X + m , greater < int > ( ) ) ; sort ( Y , Y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
int ksmallest ( int arr [ ] , int n , int k ) { int b [ MAX ] ; memset ( b , 0 , sizeof b ) ; for ( int i = 0 ; i < n ; i ++ ) b [ arr [ i ] ] = 1 ; for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) k -- ; if ( ! k ) return j ; } }
int minPalPartion ( char * str ) { int n = strlen ( str ) ; int C [ n ] ; bool P [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ; } } for ( i = 0 ; i < n ; i ++ ) { if ( P [ 0 ] [ i ] == true ) C [ i ] = 0 ; else { C [ i ] = INT_MAX ; for ( j = 0 ; j < i ; j ++ ) { if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ] ; } } } return C [ n - 1 ] ; }
bool isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
void printLevels ( vector < int > graph [ ] , int V , int x ) { int level [ V ] ; bool marked [ V ] ; queue < int > que ; que . push ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( ! que . empty ( ) ) { x = que . front ( ) ; que . pop ( ) ; for ( int i = 0 ; i < graph [ x ] . size ( ) ; i ++ ) { int b = graph [ x ] [ i ] ; if ( ! marked [ b ] ) { que . push ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } cout << " Nodes " << " ▁ ▁ ▁ ▁ " << " Level " << endl ; for ( int i = 0 ; i < V ; i ++ ) cout << " ▁ " << i << " ▁ ▁ ▁ - - > ▁ ▁ ▁ " << level [ i ] << endl ; }
int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = - 1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
int dealnnoy ( int n , int m ) { if ( m == 0 || n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
bool subArrayExists ( int arr [ ] , int n ) { unordered_set < int > sumSet ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 || sumSet . find ( sum ) != sumSet . end ( ) ) return true ; sumSet . insert ( sum ) ; } return false ; }
void merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = ar1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar1 [ j ] > ar2 [ i ] ; j -- ) ar1 [ j + 1 ] = ar1 [ j ] ; if ( j != m - 2 || last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } }
void longestString ( string str1 , string str2 ) { int count1 [ 26 ] = { 0 } , count2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; string result ; for ( int i = 0 ; i < 26 ; i ++ ) for ( int j = 1 ; j <= min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) result . push_back ( ' a ' + i ) ; cout << result ; }
unsigned int fact ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
string decodeMedianString ( string s ) { int l = s . length ( ) ; string s1 = " " ; bool isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s [ i ] + s1 ; s1 += s [ i + 1 ] ; } else { if ( l - i > 1 ) { s1 += s [ i ] ; s1 = s [ i + 1 ] + s1 ; } else { s1 += s [ i ] ; } } } return s1 ; }
int MaximumPath ( int Mat [ ] [ N ] ) { int result = 0 ; int dp [ N ] [ N + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
int minSwap ( int * arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = min ( ans , bad ) ; } return ans ; }
void decToOctal ( int n ) { int octalNum [ 100 ] ; int i = 0 ; while ( n != 0 ) { octalNum [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << octalNum [ j ] ; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return n * ( n + 1 ) / 2 ; int d = log10 ( n ) ; int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ceil ( pow ( 10 , i - 1 ) ) ; int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ; }
double vol_tetra ( int side ) { double volume = ( pow ( side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return volume ; }
void myCopy ( char s1 [ ] , char s2 [ ] , int index = 0 ) { s2 [ index ] = s1 [ index ] ; if ( s1 [ index ] == ' \0' ) return ; myCopy ( s1 , s2 , index + 1 ) ; }
int findFlips ( char str [ ] , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; }
void interLeaveQueue ( queue < int > & q ) { if ( q . size ( ) % 2 != 0 ) cout << " Input ▁ even ▁ number ▁ of ▁ integers . " << endl ; stack < int > s ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . front ( ) ) ; q . pop ( ) ; } while ( ! s . empty ( ) ) { q . push ( s . top ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . push ( q . front ( ) ) ; q . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . front ( ) ) ; q . pop ( ) ; } while ( ! s . empty ( ) ) { q . push ( s . top ( ) ) ; s . pop ( ) ; q . push ( q . front ( ) ) ; q . pop ( ) ; } }
void oddEvenSort ( int arr [ ] , int n ) { bool isSorted = false ; while ( ! isSorted ) { isSorted = true ; for ( int i = 1 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; isSorted = false ; } } for ( int i = 0 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; isSorted = false ; } } } return ; }
int shortestSeq ( char * S , char * T ) { int m = strlen ( S ) , n = strlen ( T ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ 0 ] [ i ] = MAX ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) if ( T [ k ] == ch ) break ; if ( k == - 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) ans = - 1 ; return ans ; }
int findLongestConseqSubseq ( int arr [ ] , int n ) { unordered_set < int > S ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) S . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) { int j = arr [ i ] ; while ( S . find ( j ) != S . end ( ) ) j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } return ans ; }
void printPowerSet ( char * set , int set_size ) { unsigned int pow_set_size = pow ( 2 , set_size ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { for ( j = 0 ; j < set_size ; j ++ ) { if ( counter & ( 1 << j ) ) cout << set [ j ] ; } cout << endl ; } }
int getMissingNo ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }
void printRotatedString ( char str [ ] ) { int n = strlen ( str ) ; char temp [ 2 * n + 1 ] ; strcpy ( temp , str ) ; strcat ( temp , str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) printf ( " % c " , temp [ i + j ] ) ; printf ( " \n " ) ; } }
int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
int possibleWays ( int n , int m , int k ) { int dp [ N ] [ N ] ; int presum [ N ] [ N ] ; memset ( dp , 0 , sizeof dp ) ; memset ( presum , 0 , sizeof presum ) ; for ( int i = 1 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = 0 ; presum [ 0 ] [ i ] = 1 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ; if ( j > k ) { dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ; } } for ( int j = 1 ; j < n + 1 ; j ++ ) presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ; } return dp [ m ] [ n ] ; }
void findRoots ( int a , int b , int c ) { if ( a == 0 ) { cout << " Invalid " ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ different ▁ \n " ; cout << ( double ) ( - b + sqrt_val ) / ( 2 * a ) << " \n " << ( double ) ( - b - sqrt_val ) / ( 2 * a ) ; } else if ( d == 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ same ▁ \n " ; cout << - ( double ) b / ( 2 * a ) ; } else { cout << " Roots ▁ are ▁ complex ▁ \n " ; cout << - ( double ) b / ( 2 * a ) << " ▁ + ▁ i " << sqrt_val << " \n " << - ( double ) b / ( 2 * a ) << " ▁ - ▁ i " << sqrt_val ; } }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int sum ( int a [ ] , int n ) { unordered_map < int , int > cnt ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt [ a [ i ] - 1 ] ) ans -= cnt [ a [ i ] - 1 ] ; if ( cnt [ a [ i ] + 1 ] ) ans += cnt [ a [ i ] + 1 ] ; cnt [ a [ i ] ] ++ ; } return ans ; }
int minimumSquare ( int m , int n ) { int vertical_min = INT_MAX ; int horizontal_min = INT_MAX ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] ) return dp [ m ] [ n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; }
void cycleSort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { int item = arr [ cycle_start ] ; int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle_start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle_start ) { swap ( item , arr [ pos ] ) ; writes ++ ; } while ( pos != cycle_start ) { pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { swap ( item , arr [ pos ] ) ; writes ++ ; } } } }
long long int countNonDecreasing ( int n ) { long long int dp [ 10 ] [ n + 1 ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } long long int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << " Angle ▁ not ▁ possible " ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } }
void KSwapMaximum ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int indexPosition = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( k <= j - i ) break ; if ( arr [ j ] > arr [ indexPosition ] ) indexPosition = j ; } for ( int j = indexPosition ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= indexPosition - i ; } }
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ! ( n & m ) ) { m = m << 1 ; position ++ ; } return position ; }
void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) cout << arr1 [ i ] << " ▁ " << arr2 [ j ] << endl ; }
int sparseSearch ( string arr [ ] , string x , int n ) { return binarySearch ( arr , 0 , n - 1 , x ) ; }
void printDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; }
int countSeq ( int n , int diff ) { if ( abs ( diff ) > n ) return 0 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && abs ( diff ) == 1 ) return 1 ; int res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ; return res ; }
void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n ) { int maxLen = 0 ; int preSum1 = 0 , preSum2 = 0 ; int diff [ 2 * n + 1 ] ; memset ( diff , - 1 , sizeof ( diff ) ) ; for ( int i = 0 ; i < n ; i ++ ) { preSum1 += arr1 [ i ] ; preSum2 += arr2 [ i ] ; int curr_diff = preSum1 - preSum2 ; int diffIndex = n + curr_diff ; if ( curr_diff == 0 ) maxLen = i + 1 ; else if ( diff [ diffIndex ] == - 1 ) diff [ diffIndex ] = i ; else { int len = i - diff [ diffIndex ] ; if ( len > maxLen ) maxLen = len ; } } return maxLen ; }
void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) swap ( a [ j - 1 ] , a [ j ] ) ; }
int findCount ( string str ) { int result = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( i == ( str [ i ] - ' a ' ) || i == ( str [ i ] - ' A ' ) ) result ++ ; return result ; }
void printSumTricky ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; int stripSum [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; cout << sum << " ▁ ▁ " ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; cout << sum << " ▁ ▁ " ; } cout << endl ; } }
int countPairs ( string s ) { int cnt [ MAX ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; }
int eulerian ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
unsigned countWords ( char * str ) { int state = OUT ; unsigned wc = 0 ; while ( * str ) { if ( * str == ' ▁ ' || * str == ' \n ' || * str == ' \t ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ str ; } return wc ; }
int findPossibleMoves ( int mat [ n ] [ m ] , int p , int q ) { int X [ 8 ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; int Y [ 8 ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
bool pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
void PerformQueries ( vector < int > & a , vector < pair < long long , int > > & vec ) { vector < int > ans ; int n = ( int ) a . size ( ) - 1 ; int q = ( int ) vec . size ( ) ; for ( int i = 0 ; i < q ; ++ i ) { long long t = vec [ i ] . first ; int m = vec [ i ] . second ; if ( m > n ) { ans . push_back ( - 1 ) ; continue ; } int turn = t / n ; int rem = t % n ; if ( rem == 0 and turn % 2 == 1 ) { ans . push_back ( - 1 ) ; continue ; } if ( rem == 0 and turn % 2 == 0 ) { ans . push_back ( a [ m ] ) ; continue ; } if ( turn % 2 == 0 ) { int cursize = n - rem ; if ( cursize < m ) { ans . push_back ( - 1 ) ; continue ; } ans . push_back ( a [ m + rem ] ) ; } else { int cursize = rem ; if ( cursize < m ) { ans . push_back ( - 1 ) ; continue ; } ans . push_back ( a [ m ] ) ; } } for ( int i : ans ) cout << i << " \n " ; }
int findSum ( int arr [ ] , int n ) { int sum = 0 ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { sum += arr [ i ] ; s . insert ( arr [ i ] ) ; } } return sum ; }
int count9s ( char number [ ] ) { int n = strlen ( number ) ; int d [ 9 ] ; memset ( d , 0 , sizeof ( d ) ) ; d [ 0 ] = 1 ; int result = 0 ; int mod_sum = 0 , continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! int ( number [ i ] - '0' ) ) continuous_zero ++ ; else continuous_zero = 0 ; mod_sum += int ( number [ i ] - '0' ) ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; }
bool areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( set1 [ i ] == set2 [ j ] ) return false ; return true ; }
unsigned getNthUglyNo ( unsigned n ) { unsigned ugly [ n ] ; unsigned i2 = 0 , i3 = 0 , i5 = 0 ; unsigned next_multiple_of_2 = 2 ; unsigned next_multiple_of_3 = 3 ; unsigned next_multiple_of_5 = 5 ; unsigned next_ugly_no = 1 ; ugly [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { next_ugly_no = min ( next_multiple_of_2 , min ( next_multiple_of_3 , next_multiple_of_5 ) ) ; ugly [ i ] = next_ugly_no ; if ( next_ugly_no == next_multiple_of_2 ) { i2 = i2 + 1 ; next_multiple_of_2 = ugly [ i2 ] * 2 ; } if ( next_ugly_no == next_multiple_of_3 ) { i3 = i3 + 1 ; next_multiple_of_3 = ugly [ i3 ] * 3 ; } if ( next_ugly_no == next_multiple_of_5 ) { i5 = i5 + 1 ; next_multiple_of_5 = ugly [ i5 ] * 5 ; } } return next_ugly_no ; }
int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return min ( incl , excl ) ; }
int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
void find3largest ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { cout << arr [ n - i ] << " ▁ " ; check = arr [ n - i ] ; count ++ ; } } else break ; } }
void countCurrency ( int amount ) { int notes [ 9 ] = { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 } ; int noteCounter [ 9 ] = { 0 } ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } cout << " Currency ▁ Count ▁ - > " << endl ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { cout << notes [ i ] << " ▁ : ▁ " << noteCounter [ i ] << endl ; } } }
void translate ( char * str ) { if ( str [ 0 ] == '' ) return ; for ( int i = 1 ; str [ i ] != '' ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; for ( int j = i ; str [ j ] != '' ; j ++ ) str [ j ] = str [ j + 1 ] ; } } return ; }
void PrintMinNumberForPattern ( string arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr [ i ] ) { case ' I ' : j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; cout << " ▁ " << ++ last_entry ; cout << " ▁ " << curr_max ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; cout << " ▁ " << last_entry ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { cout << " ▁ " << -- last_entry ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; cout << " ▁ " << curr_max << " ▁ " << curr_max - 1 ; last_entry = curr_max - 1 ; } else { cout << " ▁ " << last_entry - 1 ; last_entry -- ; } break ; } } cout << endl ; }
int countSubstr ( string s ) { int n = s . length ( ) ; int auxArr [ n ] = { 0 } ; if ( s [ 0 ] == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == '1' ) count += auxArr [ i ] ; return count ; }
int countDivisbleby4 ( char s [ ] ) { int n = strlen ( s ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( s [ i ] == '4' || s [ i ] == '8' || s [ i ] == '0' ) count ++ ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) ; if ( h % 4 == 0 ) count = count + i + 1 ; } return count ; }
bool areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { sort ( set1 , set1 + m ) ; sort ( set2 , set2 + n ) ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set2 [ j ] < set1 [ i ] ) j ++ ; else return false ; } return true ; }
int countStrs ( int n ) { long int dp [ n + 1 ] [ 27 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= 25 ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 25 ; j ++ ) if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } long int sum = 0 ; for ( int i = 0 ; i <= 25 ; i ++ ) sum = ( sum + dp [ n ] [ i ] ) ; return sum ; }
int findCountOfSolutions ( int n , int p ) { ll ans = 0 ; for ( ll x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { ll last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
int maxProd ( int n ) { if ( n == 0 || n == 1 ) return 0 ; int max_val = 0 ; for ( int i = 1 ; i < n ; i ++ ) max_val = max ( max_val , i * ( n - i ) , maxProd ( n - i ) * i ) ; return max_val ; }
string printNumbers ( int numbers [ ] , int n ) { vector < int > oneTwoThree ; for ( int i = 0 ; i < n ; i ++ ) { if ( findContainsOneTwoThree ( numbers [ i ] ) ) oneTwoThree . push_back ( numbers [ i ] ) ; } sort ( oneTwoThree . begin ( ) , oneTwoThree . end ( ) ) ; string result = " " ; for ( auto number : oneTwoThree ) { int value = number ; if ( result . length ( ) > 0 ) result += " , ▁ " ; result += to_string ( value ) ; } return ( result . length ( ) > 0 ) ? result : " - 1" ; }
unsigned int swapBits ( unsigned int x ) { unsigned int even_bits = x & 0xAAAAAAAA ; unsigned int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits | odd_bits ) ; }
int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int res = INT_MAX ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = min ( res , curSeqDiff ) ; } return res ; }
int bellNumber ( int n ) { int bell [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = INT_MAX ; int min_so_far = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 0 ) return 1 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
void myCopy ( char s1 [ ] , char s2 [ ] ) { int i = 0 ; for ( i = 0 ; s1 [ i ] != ' \0' ; i ++ ) s2 [ i ] = s1 [ i ] ; s2 [ i ] = ' \0' ; }
int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
string convert ( string s ) { int n = s . length ( ) ; s [ 0 ] = tolower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s [ i + 1 ] = tolower ( s [ i + 1 ] ) ; i ++ ; } else s [ i ] = toupper ( s [ i ] ) ; } return s ; }
void manipulated_seive ( int N ) { isprime [ 0 ] = isprime [ 1 ] = false ; for ( long long int i = 2 ; i < N ; i ++ ) { if ( isprime [ i ] ) { prime . push_back ( i ) ; SPF [ i ] = i ; } for ( long long int j = 0 ; j < ( int ) prime . size ( ) && i * prime [ j ] < N && prime [ j ] <= SPF [ i ] ; j ++ ) { isprime [ i * prime [ j ] ] = false ; SPF [ i * prime [ j ] ] = prime [ j ] ; } } }
long long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; }
int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ; int h [ M ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }
void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; } }
long long int calculateSum ( int n ) { long long int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
bool isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; if ( m < n ) return 0 ; sort ( arr1 , arr1 + m ) ; sort ( arr2 , arr2 + n ) ; while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) j ++ ; else if ( arr1 [ j ] == arr2 [ i ] ) { j ++ ; i ++ ; } else if ( arr1 [ j ] > arr2 [ i ] ) return 0 ; } return ( i < n ) ? false : true ; }
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
int maxSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
int numoffbt ( int arr [ ] , int n ) { int maxvalue = INT_MIN , minvalue = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { maxvalue = max ( maxvalue , arr [ i ] ) ; minvalue = min ( minvalue , arr [ i ] ) ; } int mark [ maxvalue + 2 ] ; int value [ maxvalue + 2 ] ; memset ( mark , 0 , sizeof ( mark ) ) ; memset ( value , 0 , sizeof ( value ) ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ arr [ i ] ] = 1 ; value [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int i = minvalue ; i <= maxvalue ; i ++ ) { if ( mark [ i ] ) { for ( int j = i + i ; j <= maxvalue && j / i <= i ; j += i ) { if ( ! mark [ j ] ) continue ; value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; } } ans += value [ i ] ; } return ans ; }
void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) printf ( " % d\t ▁ " , ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) ) ; else printf ( " % d\t ▁ " , ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) ; } printf ( " \n " ) ; } }
int printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { printf ( " % 2d " , m ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; printf ( " % 4d " , binom ) ; } printf ( " \n " ) ; } }
int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
int solve ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int k ) { int min_diff , current_diff , max_term ; min_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
int MaxSumDifference ( int a [ ] , int n ) { vector < int > finalSequence ; sort ( a , a + n ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . push_back ( a [ i ] ) ; finalSequence . push_back ( a [ n - i - 1 ] ) ; } int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ; } MaximumSum = MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ; return MaximumSum ; }
int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; }
double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
void drawPattern ( int N ) { int n = N ; int row = 1 ; int nst = 1 ; int nsp1 = n - 1 ; int nsp2 = - 1 ; int val1 = row ; int val2 = 1 ; while ( row <= n ) { int csp1 = 1 ; while ( csp1 <= nsp1 ) { cout << " ▁ " << " ▁ " ; csp1 = csp1 + 1 ; } int cst1 = 1 ; while ( cst1 <= nst ) { cout << val1 << " ▁ " ; val1 = val1 - 1 ; cst1 = cst1 + 1 ; } int csp2 = 1 ; while ( csp2 <= nsp2 ) { cout << " ▁ " << " ▁ " ; csp2 = csp2 + 1 ; } if ( row != 1 && row != n ) { int cst2 = 1 ; while ( cst2 <= nst ) { cout << val2 << " ▁ " ; val2 = val2 + 1 ; cst2 = cst2 + 1 ; } } cout << endl ; if ( row <= n / 2 ) { nst = nst + 1 ; nsp1 = nsp1 - 2 ; nsp2 = nsp2 + 2 ; val1 = row + 1 ; val2 = 1 ; } else { nst = nst - 1 ; nsp1 = nsp1 + 2 ; nsp2 = nsp2 - 2 ; val1 = n - row ; val2 = 1 ; } row = row + 1 ; } }
bool findWinner ( int x , int y , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 and ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 and ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 and ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
int find_difference ( int arr [ ] , int n , int m ) { int max = 0 , min = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 , j = n - 1 ; i < m ; i ++ , j -- ) { min += arr [ i ] ; max += arr [ j ] ; } return ( max - min ) ; }
bool ifPossible ( int arr [ ] , int n ) { int cp [ n ] ; copy ( arr , arr + n , cp ) ; sort ( cp , cp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; }
unsigned int doublefactorial ( unsigned int n ) { if ( n == 0 || n == 1 ) return 1 ; return n * doublefactorial ( n - 2 ) ; }
int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int start = 1 , end = x , ans ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; }
string wordReverse ( string str ) { int i = str . length ( ) - 1 ; int start , end = i + 1 ; string result = " " ; while ( i >= 0 ) { if ( str [ i ] == ' ▁ ' ) { start = i + 1 ; while ( start != end ) result += str [ start ++ ] ; result += ' ▁ ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) result += str [ start ++ ] ; return result ; }
INT_MAX int shortestPath ( int graph [ ] [ V ] , int u , int v , int k ) { int sp [ V ] [ V ] [ k + 1 ] ; for ( int e = 0 ; e <= k ; e ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { sp [ i ] [ j ] [ e ] = INF ; if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0 ; if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ; if ( e > 1 ) { for ( int a = 0 ; a < V ; a ++ ) { if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } } return sp [ u ] [ v ] [ k ] ; }
void overflow ( int H , int r , int h , int N , int R ) { float tank_cap = 3.14 * r * r * H ; float water_vol = 3.14 * r * r * h ; float balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; float vol = water_vol + balls_vol ; if ( vol > tank_cap ) { cout << " Overflow " << endl ; } else { cout << " Not ▁ in ▁ overflow ▁ state " << endl ; } }
float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }
void findAndPrintUncommonChars ( string str1 , string str2 ) { int present [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) present [ i ] = 0 ; int l1 = str1 . size ( ) ; int l2 = str2 . size ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) present [ str1 [ i ] - ' a ' ] = 1 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 [ i ] - ' a ' ] == 1 || present [ str2 [ i ] - ' a ' ] == - 1 ) present [ str2 [ i ] - ' a ' ] = - 1 ; else present [ str2 [ i ] - ' a ' ] = 2 ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( present [ i ] == 1 || present [ i ] == 2 ) cout << ( char ( i + ' a ' ) ) << " ▁ " ; }
void printDistinct ( char * str ) { int count [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) if ( * ( str + i ) != ' ▁ ' ) count [ * ( str + i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ * ( str + i ) ] == 1 ) cout << str [ i ] ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
int nobleInteger ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 || cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
int gcdOfFactorial ( int m , int n ) { return factorial ( min ( m , n ) ) ; }
void subArraySum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > map ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum = curr_sum + arr [ i ] ; if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << 0 << " ▁ to ▁ " << i << endl ; return ; } if ( map . find ( curr_sum - sum ) != map . end ( ) ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << map [ curr_sum - sum ] + 1 << " ▁ to ▁ " << i << endl ; return ; } map [ curr_sum ] = i ; } cout << " No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists " ; }
bool checkReverse ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; sort ( temp , temp + n ) ; int front ; for ( front = 0 ; front < n ; front ++ ) if ( temp [ front ] != arr [ front ] ) break ; int back ; for ( back = n - 1 ; back >= 0 ; back -- ) if ( temp [ back ] != arr [ back ] ) break ; if ( front >= back ) return true ; do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) return false ; } while ( front != back ) ; return true ; }
void freq ( int ar [ ] [ MAX ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } printf ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = ▁ % d ▁ \n " , odd ) ; printf ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ % d ▁ \n " , even ) ; }
int longLenStrictBitonicSub ( int arr [ ] , int n ) { unordered_map < int , int > inc , dcr ; int len_inc [ n ] , len_dcr [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . find ( arr [ i ] - 1 ) != inc . end ( ) ) len = inc [ arr [ i ] - 1 ] ; inc [ arr [ i ] ] = len_inc [ i ] = len + 1 ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . find ( arr [ i ] - 1 ) != dcr . end ( ) ) len = dcr [ arr [ i ] - 1 ] ; dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1 ; } for ( int i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; }
int mod ( string num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
string printShortestSuperSeq ( string X , string Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int index = dp [ m ] [ n ] ; string str ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { str . push_back ( X [ i - 1 ] ) ; i -- , j -- , index -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str . push_back ( Y [ j - 1 ] ) ; j -- , index -- ; } else { str . push_back ( X [ i - 1 ] ) ; i -- , index -- ; } } while ( i > 0 ) { str . push_back ( X [ i - 1 ] ) ; i -- , index -- ; } while ( j > 0 ) { str . push_back ( Y [ j - 1 ] ) ; j -- , index -- ; } reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int count ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } return dp [ n ] ; }
int numberOfTriangles ( int n ) { int answer [ n + 1 ] = { 0 } ; answer [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2 ; return answer [ n ] ; }
int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }
bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool dp [ n + 1 ] [ sum + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) cout << j << " ▁ " ; }
int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
void scalarProductMat ( int mat [ ] [ N ] , int k ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] * k ; }
int maxSum ( int arr [ ] , int n ) { int arrSum = 0 ; int currVal = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; } int maxVal = currVal ; for ( int j = 1 ; j < n ; j ++ ) { currVal = currVal + arrSum - n * arr [ n - j ] ; if ( currVal > maxVal ) maxVal = currVal ; } return maxVal ; }
int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 || n == 0 ) return 0 ; sort ( arr , arr + n ) ; if ( n < m ) return - 1 ; int min_diff = INT_MAX ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) { min_diff = diff ; first = i ; last = i + m - 1 ; } } return ( arr [ last ] - arr [ first ] ) ; }
int minRemove ( int a [ ] , int b [ ] , int n , int m ) { unordered_map < int , int > countA , countB ; for ( int i = 0 ; i < n ; i ++ ) countA [ a [ i ] ] ++ ; for ( int i = 0 ; i < m ; i ++ ) countB [ b [ i ] ] ++ ; int res = 0 ; for ( auto x : countA ) if ( countB . find ( x . first ) != countB . end ( ) ) res += min ( x . second , countB [ x . first ] ) ; return res ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
int arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 1 || n == 0 ) return 1 ; if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0 ; return arraySortedOrNot ( arr , n - 1 ) ; }
int minTime ( int n , int k , int a [ ] ) { sort ( a , a + n , greater < int > ( ) ) ; int minTime = 0 ; for ( int i = 0 ; i < n ; i += k ) minTime += ( 2 * a [ i ] ) ; return minTime ; }
int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
void find_max ( int A [ ] , int N , int K ) { map < int , int > Count ; for ( int i = 0 ; i < K - 1 ; i ++ ) Count [ A [ i ] ] ++ ; set < int > Myset ; for ( auto x : Count ) if ( x . second == 1 ) Myset . insert ( x . first ) ; for ( int i = K - 1 ; i < N ; i ++ ) { Count [ A [ i ] ] ++ ; if ( Count [ A [ i ] ] == 1 ) Myset . insert ( A [ i ] ) ; else Myset . erase ( A [ i ] ) ; if ( Myset . size ( ) == 0 ) printf ( " Nothing \n " ) ; else printf ( " % d \n " , * Myset . rbegin ( ) ) ; int x = A [ i - K + 1 ] ; Count [ x ] -- ; if ( Count [ x ] == 1 ) Myset . insert ( x ) ; if ( Count [ x ] == 0 ) Myset . erase ( x ) ; } }
int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ; }
int totalNodes ( vector < int > adjac [ ] , int n , int x , int y ) { bool visited [ n + 1 ] = { 0 } ; int p [ n ] ; queue < int > q ; q . push ( x ) ; visited [ x ] = true ; int m ; while ( ! q . empty ( ) ) { m = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < adjac [ m ] . size ( ) ; ++ i ) { int h = adjac [ m ] [ i ] ; if ( ! visited [ h ] ) { visited [ h ] = true ; p [ h ] = m ; q . push ( h ) ; } } } int count = 0 ; int i = p [ y ] ; while ( i != x ) { count ++ ; i = p [ i ] ; } return count ; }
int solve ( int A [ ] , int n ) { int i , cnt = 0 , j ; int parent [ n + 1 ] ; int vis [ n + 1 ] ; memset ( parent , - 1 , sizeof ( parent ) ) ; memset ( vis , 0 , sizeof ( vis ) ) ; for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( ! vis [ j ] ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; }
int countDistictSubarray ( int arr [ ] , int n ) { unordered_map < int , int > vis ; for ( int i = 0 ; i < n ; ++ i ) vis [ arr [ i ] ] = 1 ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { ++ vis [ arr [ right ] ] ; if ( vis [ arr [ right ] ] == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; -- vis [ arr [ left ] ] ; if ( vis [ arr [ left ] ] == 0 ) -- window ; } return ans ; }
int MinOperation ( int a [ ] , int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }
int minHeight ( int base , int area ) { return ceil ( ( float ) ( 2 * area ) / base ) ; }
bool checkSentence ( char str [ ] ) { int len = strlen ( str ) ; if ( str [ 0 ] < ' A ' || str [ 0 ] > ' Z ' ) return false ; if ( str [ len - 1 ] != ' . ' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( str [ index ] ) { if ( str [ index ] >= ' A ' && str [ index ] <= ' Z ' ) curr_state = 0 ; else if ( str [ index ] == ' ▁ ' ) curr_state = 1 ; else if ( str [ index ] >= ' a ' && str [ index ] <= ' z ' ) curr_state = 2 ; else if ( str [ index ] == ' . ' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( str [ index + 1 ] == ' \0' ) ; index ++ ; prev_state = curr_state ; } return false ; }
void alternateSort ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { cout << arr [ j -- ] << " ▁ " ; cout << arr [ i ++ ] << " ▁ " ; } if ( n % 2 != 0 ) cout << arr [ i ] ; }
unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
int findMaxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } return res ; }
void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) { double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; cout << " ( " << x << " , ▁ " ; cout << y << " ) " << endl ; }
bool checkPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; sum = sum / 2 ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . find ( val ) != s . end ( ) ) { printf ( " Pair ▁ elements ▁ are ▁ % d ▁ and ▁ % d \n " , arr [ i ] , val ) ; return true ; } s . insert ( arr [ i ] ) ; } return false ; }
int countFibs ( int low , int high ) { int f1 = 0 , f2 = 1 , f3 = 1 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) result ++ ; f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }
int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } }
int kthNonRepeating ( string str , int k ) { int n = str . length ( ) ; int count [ MAX_CHAR ] ; int index [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str [ i ] ; ++ count [ x ] ; if ( count [ x ] == 1 ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } sort ( index , index + MAX_CHAR ) ; return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1 ; }
int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " ▁ , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
void groupElements ( int arr [ ] , int n ) { bool * visited = new bool [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ i ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { cout << arr [ i ] << " ▁ " ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { cout << arr [ i ] << " ▁ " ; visited [ j ] = true ; } } } } delete [ ] visited ; }
bool arekAnagrams ( string str1 , string str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
void printPrevSmaller ( int arr [ ] , int n ) { cout << " _ , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { cout << arr [ j ] << " , ▁ " ; break ; } } if ( j == - 1 ) cout << " _ , ▁ " ; } }
int lcs ( int i , int j , int count ) { if ( i == 0 || j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }
int findLargestSumPair ( int arr [ ] , int n ) { int first , second ; if ( arr [ 0 ] > arr [ 1 ] ) { first = arr [ 0 ] ; second = arr [ 1 ] ; } else { first = arr [ 1 ] ; second = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } return ( first + second ) ; }
int check_duck ( char * num ) { int len = strlen ( num ) ; int count_zero = 0 ; char ch ; for ( int i = 1 ; i < len ; i ++ ) { ch = num [ i ] ; if ( ch == '0' ) count_zero ++ ; } return count_zero ; }
bool checkIfAllTogether ( string s , char c ) { bool oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
bool areElementsContiguous ( int arr [ ] , int n ) { unordered_set < int > us ; for ( int i = 0 ; i < n ; i ++ ) us . insert ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele ++ ; } return ( count == ( int ) ( us . size ( ) ) ) ; }
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int minStringValue ( string str , int k ) { int l = str . length ( ) ; if ( k >= l ) return 0 ; int frequency [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) frequency [ str [ i ] - ' a ' ] ++ ; priority_queue < int > q ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) q . push ( frequency [ i ] ) ; while ( k -- ) { int temp = q . top ( ) ; q . pop ( ) ; temp = temp - 1 ; q . push ( temp ) ; } int result = 0 ; while ( ! q . empty ( ) ) { int temp = q . top ( ) ; result += temp * temp ; q . pop ( ) ; } return result ; }
void reverseFibonacci ( int n ) { int a [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { cout << a [ i ] << " ▁ " ; } }
int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { unordered_map < int , int > um ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um [ curr_sum ] ++ ; } int count = 0 ; for ( auto itr = um . begin ( ) ; itr != um . end ( ) ; itr ++ ) { if ( itr -> second > 1 ) count += ( ( itr -> second * ( itr -> second - 1 ) ) / 2 ) ; } if ( um . find ( 0 ) != um . end ( ) ) count += um [ 0 ] ; return count ; }
int bool isLucky ( int n ) { static int counter = 2 ; int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
int count ( char s [ ] , int len ) { int cur = 0 , dig = 0 ; int sum [ MAX ] , dp [ MAX ] [ 3 ] ; memset ( sum , 0 , sizeof ( sum ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = int ( s [ i - 1 ] ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = int ( s [ i - 1 ] ) - 48 ; if ( dig == 8 ) ans ++ ; if ( i - 2 >= 0 ) { dprev = int ( s [ i - 2 ] ) - 48 ; value = dprev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ; } if ( i - 3 >= 0 ) { dprev2 = int ( s [ i - 3 ] ) - 48 ; dprev = int ( s [ i - 2 ] ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 8 != 0 ) continue ; ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
int countDyckPaths ( unsigned int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
void swap ( int * xp , int * yp ) { if ( xp == yp ) return ; * xp = * xp + * yp ; * yp = * xp - * yp ; * xp = * xp - * yp ; }
int maxProfit ( int price [ ] , int n , int k ) { int profit [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = INT_MIN ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) cout << a [ i ] << " ▁ " ; } }
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " ▁ " ; printSorted ( arr , start * 2 + 2 , end ) ; }
int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return - 1 ; int smallest = a [ 0 ] [ 0 ] , largest = a [ n - 1 ] [ n - 1 ] ; if ( x < smallest || x > largest ) return - 1 ; int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << " n ▁ Found ▁ at ▁ " << i << " , ▁ " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; }
int findInteger ( int arr [ ] , int n ) { int neg = 0 , pos = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] < 0 ) neg ++ ; else pos ++ ; } return ( sum / abs ( neg - pos ) ) ; }
int countGroups ( int position , int previous_sum , int length , char * num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
void digitsNum ( int N ) { if ( N == 0 ) cout << "0 \n " ; if ( N % 9 != 0 ) cout << ( N % 9 ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) cout << "9" ; for ( int i = 1 ; i <= N ; ++ i ) cout << "0" ; cout << " \n " ; }
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << " Touch " << endl ; else if ( radius > dist ) cout << " Intersect " << endl ; else cout << " Outside " << endl ; }
int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return abs ( d1 - d2 ) ; }
float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; }
int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
int lps ( string & s ) { int n = s . length ( ) ; int a [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int back_up = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( j == i ) a [ j ] = 1 ; else if ( s [ i ] == s [ j ] ) { int temp = a [ j ] ; a [ j ] = back_up + 2 ; back_up = temp ; } else { back_up = a [ j ] ; a [ j ] = max ( a [ j - 1 ] , a [ j ] ) ; } } } return a [ n - 1 ] ; }
double squareRoot ( double n ) { return pow ( 2 , 0.5 * log2 ( n ) ) ; }
void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; }
void bestApproximate ( int x [ ] , int y [ ] , int n ) { float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; cout << " m ▁ = " << m ; cout << " \n c ▁ = " << c ; }
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
void printArray ( int arr [ ] [ 5 ] , int row , int col ) { unordered_set < string > uset ; for ( int i = 0 ; i < row ; i ++ ) { string s = " " ; for ( int j = 0 ; j < col ; j ++ ) s += to_string ( arr [ i ] [ j ] ) ; if ( uset . count ( s ) == 0 ) { uset . insert ( s ) ; cout << s << endl ; } } }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
int maxLevel ( int boxes [ ] , int n ) { sort ( boxes , boxes + n ) ; int ans = 1 ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
int MaximumHeight ( int a [ ] , int n ) { return floor ( ( - 1 + sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; }
int compute ( vector < int > graph [ ] , int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) if ( graph [ i ] . size ( ) == 0 ) count ++ ; return count ; }
int productAtKthLevel ( string tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; }
void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { cout << 0 ; return ; } int * left = new int [ sizeof ( int ) * n ] ; int * right = new int [ sizeof ( int ) * n ] ; int * prod = new int [ sizeof ( int ) * n ] ; int i , j ; left [ 0 ] = 1 ; right [ n - 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) prod [ i ] = left [ i ] * right [ i ] ; for ( i = 0 ; i < n ; i ++ ) cout << prod [ i ] << " ▁ " ; return ; }
void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr1 [ i ] ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . find ( x - arr2 [ j ] ) != s . end ( ) ) cout << x - arr2 [ j ] << " ▁ " << arr2 [ j ] << endl ; }
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
int printKDistinct ( int arr [ ] , int n , int k ) { unordered_map < int , int > h ; for ( int i = 0 ; i < n ; i ++ ) h [ arr [ i ] ] ++ ; if ( h . size ( ) < k ) return - 1 ; int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h [ arr [ i ] ] == 1 ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
int minInsertion ( string str ) { int n = str . length ( ) ; int res = 0 ; int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( count [ i ] % 2 == 1 ) res ++ ; return ( res == 0 ) ? 0 : res - 1 ; }
void printStringAlternate ( string str ) { unordered_map < char , int > occ ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char temp = tolower ( str [ i ] ) ; occ [ temp ] ++ ; if ( occ [ temp ] & 1 ) cout << str [ i ] ; } cout << endl ; }
int maxTripletSum ( int arr [ ] , int n ) { int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }
int dayofweek ( int d , int m , int y ) { static int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; y -= m < 3 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
void longestSubsequence ( int a [ ] , int n ) { unordered_map < int , int > mp ; int dp [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int maximum = INT_MIN ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( a [ i ] - 1 ) != mp . end ( ) ) { int lastIndex = mp [ a [ i ] - 1 ] - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else dp [ i ] = 1 ; mp [ a [ i ] ] = i + 1 ; if ( maximum < dp [ i ] ) { maximum = dp [ i ] ; index = i ; } } for ( int curr = a [ index ] - maximum + 1 ; curr <= a [ index ] ; curr ++ ) cout << curr << " ▁ " ; }
bool isPowerOfK ( unsigned int n , unsigned int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
int findIndex ( string str ) { int len = str . length ( ) ; int open [ len + 1 ] , close [ len + 1 ] ; int index = - 1 ; memset ( open , 0 , sizeof ( open ) ) ; memset ( close , 0 , sizeof ( close ) ) ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str [ 0 ] == ' ( ' ) open [ 1 ] = 1 ; if ( str [ len - 1 ] == ' ) ' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == ' ( ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ) ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }
void findTriplets ( int arr [ ] , int n ) { bool found = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { cout << arr [ i ] << " ▁ " << arr [ j ] << " ▁ " << arr [ k ] << endl ; found = true ; } } } } if ( found == false ) cout << " ▁ not ▁ exist ▁ " << endl ; }
int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
string longestRepeatedSubstring ( string str ) { int n = str . length ( ) ; int LCSRe [ n + 1 ] [ n + 1 ] ; memset ( LCSRe , 0 , sizeof ( LCSRe ) ) ; string res ; int res_length = 0 ; int i , index = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) { LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ; if ( LCSRe [ i ] [ j ] > res_length ) { res_length = LCSRe [ i ] [ j ] ; index = max ( i , index ) ; } } else LCSRe [ i ] [ j ] = 0 ; } } if ( res_length > 0 ) for ( i = index - res_length + 1 ; i <= index ; i ++ ) res . push_back ( str [ i - 1 ] ) ; return res ; }
void bubbleSort ( int arr [ ] , int n ) { int i , j ; bool swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( & arr [ j ] , & arr [ j + 1 ] ) ; swapped = true ; } } if ( swapped == false ) break ; } }
int minStepToDeleteString ( string str ) { int N = str . length ( ) ; int dp [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
int floorSearch ( int arr [ ] , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid - 1 , x ) ; return floorSearch ( arr , mid + 1 , high , x ) ; }
bool areAnagram ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return false ; sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ; return true ; }
int findMaxSegment ( string & s , int k ) { int seg_len = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < seg_len ; i ++ ) res = res * 10 + ( s [ i ] - '0' ) ; int seg_len_pow = pow ( 10 , seg_len - 1 ) ; int curr_val = res ; for ( int i = 1 ; i <= ( s . length ( ) - seg_len ) ; i ++ ) { curr_val = curr_val - ( s [ i - 1 ] - '0' ) * seg_len_pow ; curr_val = curr_val * 10 + ( s [ i + seg_len - 1 ] - '0' ) ; res = max ( res , curr_val ) ; } return res ; }
void rearrangeArray ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int tempArr [ n ] ; int ArrIndex = 0 ; for ( int i = 0 , j = n - 1 ; i <= n / 2 || j > n / 2 ; i ++ , j -- ) { tempArr [ ArrIndex ] = arr [ i ] ; ArrIndex ++ ; tempArr [ ArrIndex ] = arr [ j ] ; ArrIndex ++ ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = tempArr [ i ] ; }
int mostFrequent ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int max_count = 1 , res = arr [ 0 ] , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int sumOfSeries ( int n ) { return 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ; }
int minSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
int perfectSquare ( string s ) { int n = s . size ( ) ; int ans = - 1 ; string num ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { string str = " " ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i >> j ) & 1 ) { str += s [ j ] ; } } if ( str [ 0 ] != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . size ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str [ j ] - '0' ) ; int k = sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . size ( ) ) { ans = ( int ) str . size ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { cout << num << " ▁ " ; return n - ans ; } }
bool checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }
bool checkStackPermutation ( int ip [ ] , int op [ ] , int n ) { queue < int > input ; for ( int i = 0 ; i < n ; i ++ ) input . push ( ip [ i ] ) ; queue < int > output ; for ( int i = 0 ; i < n ; i ++ ) output . push ( op [ i ] ) ; stack < int > tempStack ; while ( ! input . empty ( ) ) { int ele = input . front ( ) ; input . pop ( ) ; if ( ele == output . front ( ) ) { output . pop ( ) ; while ( ! tempStack . empty ( ) ) { if ( tempStack . top ( ) == output . front ( ) ) { tempStack . pop ( ) ; output . pop ( ) ; } else break ; } } else tempStack . push ( ele ) ; } return ( input . empty ( ) && tempStack . empty ( ) ) ; }
int replaceSpaces ( char str [ ] ) { int space_count = 0 , i ; for ( i = 0 ; str [ i ] ; i ++ ) if ( str [ i ] == ' ▁ ' ) space_count ++ ; while ( str [ i - 1 ] == ' ▁ ' ) { space_count -- ; i -- ; } int new_length = i + space_count * 2 + 1 ; if ( new_length > MAX ) return - 1 ; int index = new_length - 1 ; str [ index -- ] = ' \0' ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( str [ j ] == ' ▁ ' ) { str [ index ] = '0' ; str [ index - 1 ] = '2' ; str [ index - 2 ] = ' % ' ; index = index - 3 ; } else { str [ index ] = str [ j ] ; index -- ; } } return new_length ; }
void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) pow ( 10 , temp ) ; palindrome += n - 1 ; printf ( " % d " , palindrome ) ; if ( k & 1 ) palindrome /= 10 ; while ( palindrome ) { printf ( " % d " , palindrome % 10 ) ; palindrome /= 10 ; } printf ( " \n " ) ; }
int getOddOccurrence ( int arr [ ] , int size ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < size ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( auto i : hash ) { if ( i . second % 2 != 0 ) { return i . first ; } } return - 1 ; }
int findCommon ( int mat [ M ] [ N ] ) { unordered_map < int , int > cnt ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { cnt [ mat [ i ] [ 0 ] ] ++ ; for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) cnt [ mat [ i ] [ j ] ] ++ ; } } for ( auto ele : cnt ) { if ( ele . second == M ) return ele . first ; } return - 1 ; }
int minCost ( int coin [ ] , int n , int k ) { sort ( coin , coin + n ) ; int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
string findSum ( string str1 , string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ; string str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i + diff ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry ) str . push_back ( carry + '0' ) ; reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
int findRepeatFirstN2 ( char * s ) { int p = - 1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( pow ( x , y ) ) ) % 10 ) ; }
int policeThief ( char arr [ ] , int n , int k ) { int res = 0 ; vector < int > thi ; vector < int > pol ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == ' P ' ) pol . push_back ( i ) ; else if ( arr [ i ] == ' T ' ) thi . push_back ( i ) ; } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( abs ( thi [ l ] - pol [ r ] ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi [ l ] < pol [ r ] ) l ++ ; else r ++ ; } return res ; }
unsigned int Calculate ( unsigned int A , unsigned int B , unsigned int C , unsigned int M ) { unsigned int res , ans ; res = power ( B , C , M - 1 ) ; ans = power ( A , res , M ) ; return ans ; }
int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int unique ( int mat [ R ] [ C ] , int n , int m ) { int maximum = 0 , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ; int b [ maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) b [ mat [ i ] [ j ] ] ++ ; for ( int i = 1 ; i <= maximum ; i ++ ) if ( b [ i ] == 1 ) cout << i << " ▁ " ; flag = 1 ; if ( ! flag ) { cout << " No ▁ unique ▁ element ▁ in ▁ the ▁ matrix " ; } }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int countSubsets ( int arr [ ] , int n ) { unordered_set < int > us ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) us . insert ( arr [ i ] ) ; unordered_set < int > :: iterator itr ; for ( itr = us . begin ( ) ; itr != us . end ( ) ; itr ++ ) even_count ++ ; return ( pow ( 2 , even_count ) - 1 ) ; }
int findSubarraySum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > prevSum ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . find ( currsum - sum ) != prevSum . end ( ) ) res += ( prevSum [ currsum - sum ] ) ; prevSum [ currsum ] ++ ; } return res ; }
int summingSeries ( long n ) { int S = 0 ; for ( int i = 1 ; i <= n ; i ++ ) S += i * i - ( i - 1 ) * ( i - 1 ) ; return S ; }
void shufleArray ( int a [ ] , int f , int l ) { if ( l > f ) { return ; } if ( l - f == 1 ) return ; int mid = ( f + l ) / 2 ; int temp = mid + 1 ; int mmid = ( f + mid ) / 2 ; for ( int i = mmid + 1 ; i <= mid ; i ++ ) swap ( a [ i ] , a [ temp ++ ] ) ; shufleArray ( a , f , mid ) ; shufleArray ( a , mid + 1 , l ) ; }
int gcdExtended ( int a , int b , int * x , int * y ) { if ( a == 0 ) { * x = 0 ; * y = 1 ; return b ; } int x1 , y1 ; int gcd = gcdExtended ( b % a , a , & x1 , & y1 ) ; * x = y1 - ( b / a ) * x1 ; * y = x1 ; return gcd ; }
void generateGrayarr ( int n ) { if ( n <= 0 ) return ; vector < string > arr ; arr . push_back ( "0" ) ; arr . push_back ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . push_back ( arr [ j ] ) ; for ( j = 0 ; j < i ; j ++ ) arr [ j ] = "0" + arr [ j ] ; for ( j = i ; j < 2 * i ; j ++ ) arr [ j ] = "1" + arr [ j ] ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << endl ; }
int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; }
int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { unordered_set < int > s ; int curr_sum = sum - A [ i ] ; for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( s . find ( curr_sum - A [ j ] ) != s . end ( ) ) { printf ( " Triplet ▁ is ▁ % d , ▁ % d , ▁ % d " , A [ i ] , A [ j ] , curr_sum - A [ j ] ) ; return true ; } s . insert ( A [ j ] ) ; } } return false ; }
string multiply ( string num1 , string num2 ) { int len1 = num1 . size ( ) ; int len2 = num2 . size ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; vector < int > result ( len1 + len2 , 0 ) ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 [ i ] - '0' ; i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 [ j ] - '0' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . size ( ) - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; string s = " " ; while ( i >= 0 ) s += std :: to_string ( result [ i -- ] ) ; return s ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
void sortString ( string & str ) { int charCount [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) charCount [ str [ i ] - ' a ' ] ++ ; for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) for ( int j = 0 ; j < charCount [ i ] ; j ++ ) cout << ( char ) ( ' a ' + i ) ; }
int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void printPrevSmaller ( int arr [ ] , int n ) { stack < int > S ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! S . empty ( ) && S . top ( ) >= arr [ i ] ) S . pop ( ) ; if ( S . empty ( ) ) cout << " _ , ▁ " ; else cout << S . top ( ) << " , ▁ " ; S . push ( arr [ i ] ) ; } }
bool checkStar ( int mat [ ] [ size ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
void computeTotient ( int n ) { long long phi [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) cout << " Totient ▁ of ▁ " << i << " ▁ is ▁ " << phi [ i ] << endl ; }
int findIndex ( int n ) { float fibo = 2.078087 * log ( n ) + 1.672276 ; return round ( fibo ) ; }
void midPoint ( int X1 , int Y1 , int X2 , int Y2 ) { int dx = X2 - X1 ; int dy = Y2 - Y1 ; int d = dy - ( dx / 2 ) ; int x = X1 , y = Y1 ; cout << x << " , " << y << " \n " ; while ( x < X2 ) { x ++ ; if ( d < 0 ) d = d + dy ; else { d += ( dy - dx ) ; y ++ ; } cout << x << " , " << y << " \n " ; } }
bool isPossible ( int n , int index , int sum , int M , int arr [ ] , int dp [ ] [ MAX ] ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } if ( dp [ index ] [ sum ] != - 1 ) return dp [ index ] [ sum ] ; bool placeAdd = isPossible ( n , index + 1 , sum + arr [ index ] , M , arr , dp ) ; bool placeMinus = isPossible ( n , index + 1 , sum - arr [ index ] , M , arr , dp ) ; bool res = ( placeAdd || placeMinus ) ; dp [ index ] [ sum ] = res ; return res ; }
void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int tempArr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; sort ( tempArr , tempArr + n ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { bool flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { cout << arr [ i + j ] << " ▁ " ; flag = true ; break ; } } if ( ! flag ) cout << "0" << " ▁ " ; } }
void sortString ( string & str ) { int charCount [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) charCount [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) for ( int j = 0 ; j < charCount [ i ] ; j ++ ) cout << ( char ) ( ' a ' + i ) ; }
bool pairWiseConsecutive ( stack < int > s ) { stack < int > aux ; while ( ! s . empty ( ) ) { aux . push ( s . top ( ) ) ; s . pop ( ) ; } bool result = true ; while ( aux . empty ( ) > 1 ) { int x = aux . top ( ) ; aux . pop ( ) ; int y = aux . top ( ) ; aux . pop ( ) ; if ( abs ( x - y ) != 1 ) result = false ; s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) s . push ( aux . top ( ) ) ; return result ; }
string nextGreater ( string num ) { int l = num . size ( ) ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( num . at ( i ) == '0' ) { num . at ( i ) = '1' ; break ; } else num . at ( i ) = '0' ; } if ( i < 0 ) num = "1" + num ; return num ; }
vector < int > Restore_Tree ( int Start [ ] , int End [ ] ) { vector < int > Identity ( N , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { Identity [ Start [ i ] ] = i ; } vector < int > parent ( N , - 1 ) ; int curr_parent = Identity [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) { int child = Identity [ j ] ; if ( End [ child ] - j > 1 ) { parent [ child ] = curr_parent ; curr_parent = child ; } else parent [ child ] = curr_parent ; while ( End [ child ] == End [ parent [ child ] ] ) { child = parent [ child ] ; curr_parent = parent [ child ] ; if ( curr_parent == Identity [ 0 ] ) break ; } } for ( int i = 0 ; i < N ; i ++ ) parent [ i ] += 1 ; return parent ; }
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " ▁ " ; C = C * ( line - i ) / i ; } cout << " \n " ; } }
int maxSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Difference ▁ = ▁ " << 0 ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 + 1 ; cout << " \n Difference ▁ = ▁ " << 1 ; } else { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Difference ▁ = ▁ " << 0 ; } } }
bool isReversible ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
char maxRepeating ( string str ) { int len = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; }
int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
void printTwoElements ( int arr [ ] , int size ) { int i ; cout << " ▁ The ▁ repeating ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else cout << abs ( arr [ i ] ) << " \n " ; } cout << " and ▁ the ▁ missing ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) cout << ( i + 1 ) ; } }
bool isSubSequence ( char str1 [ ] , char str2 [ ] , int m , int n ) { int j = 0 ; for ( int i = 0 ; i < n && j < m ; i ++ ) if ( str1 [ j ] == str2 [ i ] ) j ++ ; return ( j == m ) ; }
int SieveOfSundaram ( int n ) { int nNew = ( n - 2 ) / 2 ; bool marked [ nNew + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << " ▁ " ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << " ▁ " ; }
string findTwoscomplement ( string str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == '1' ) break ; if ( i == - 1 ) return '1' + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str [ k ] == '1' ) str [ k ] = '0' ; else str [ k ] = '1' ; } return str ; ; }
int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
int Circumference ( int l , int w ) { return ( 2 * ( l + w ) ) ; }
void sortString ( string & str ) { sort ( str . begin ( ) , str . end ( ) ) ; cout << str ; }
int countPair ( int a , int b ) { string s = to_string ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }
int minOperations ( string str , int n ) { int i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper == - 1 || firstLower == - 1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } } return min ( countLower , countUpper ) ; }
int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
void printMaxOfMin ( int arr [ ] , int n ) { stack < int > s ; int left [ n + 1 ] ; int right [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . top ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . top ( ) ; s . push ( i ) ; } int ans [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << ans [ i ] << " ▁ " ; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
void ReversespiralPrint ( int m , int n , int a [ R ] [ C ] ) { long int b [ 100 ] ; int i , k = 0 , l = 0 ; int z = 0 ; int size = m * n ; while ( k < m && l < n ) { int val ; for ( i = l ; i < n ; ++ i ) { val = a [ k ] [ i ] ; b [ z ] = val ; ++ z ; } k ++ ; for ( i = k ; i < m ; ++ i ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; ++ z ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { val = a [ m - 1 ] [ i ] ; b [ z ] = val ; ++ z ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { val = a [ i ] [ l ] ; b [ z ] = val ; ++ z ; } l ++ ; } } for ( int i = size - 1 ; i >= 0 ; -- i ) { cout << b [ i ] << " ▁ " ; } }
int MaximumHeight ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
bool pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }
int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
float areaOfInscribedCircle ( float a ) { return ( PI / 4 ) * a * a ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_so_far << endl ; cout << " Starting ▁ index ▁ " << start << endl << " Ending ▁ index ▁ " << end << endl ; }
int subsetGraph ( int C [ ] [ N ] ) { set < int > vertices ; for ( int i = 0 ; i < N ; ++ i ) vertices . insert ( i ) ; while ( ! vertices . empty ( ) ) { if ( vertices . size ( ) == 1 ) return 1 ; bool someone_removed = false ; for ( int x : vertices ) { set < int > values ; for ( int y : vertices ) if ( y != x ) values . insert ( C [ x ] [ y ] ) ; if ( values . size ( ) == 1 ) { vertices . erase ( x ) ; someone_removed = true ; break ; } } if ( ! someone_removed ) break ; } return ( vertices . size ( ) ) ; }
int maxXOR ( int mat [ ] [ MAX ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < max ( r_xor , c_xor ) ) max_xor = max ( r_xor , c_xor ) ; } return max_xor ; }
int countSubsequences ( string s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( unsigned int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
int maximumChars ( string & str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = max ( res , abs ( j - i - 1 ) ) ; return res ; }
void printRoots ( int n ) { double theta = M_PI * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = cos ( k * theta ) ; double img = sin ( k * theta ) ; printf ( " % .6f " , real ) ; img >= 0 ? printf ( " ▁ + ▁ i ▁ " ) : printf ( " ▁ - ▁ i ▁ " ) ; printf ( " % .6f \n " , abs ( img ) ) ; } }
int SieveOfAtkin ( int limit ) { if ( limit > 2 ) cout << 2 << " ▁ " ; if ( limit > 3 ) cout << 3 << " ▁ " ; bool sieve [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) cout << a << " ▁ " ; }
int smallestKFreq ( int a [ ] , int n , int k ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ a [ i ] ] ++ ; int res = INT_MAX ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; ++ it ) if ( it -> second == k ) res = min ( res , it -> first ) ; return ( res != INT_MAX ) ? res : - 1 ; }
int minimumflip ( int mat [ ] [ N ] , int n ) { int transpose [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { cout << " Invalid ▁ Input " ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } cout << " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ " << arr [ min_l ] << " ▁ and ▁ " << arr [ min_r ] ; }
void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { cout << " No ▁ pairs ▁ exists \n " ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) a = arr [ i ] , b = arr [ j ] ; cout << " Max ▁ product ▁ pair ▁ is ▁ { " << a << " , ▁ " << b << " } " ; }
int pageFaults ( int pages [ ] , int n , int capacity ) { unordered_set < int > s ; queue < int > indexes ; int page_faults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( s . find ( pages [ i ] ) == s . end ( ) ) { s . insert ( pages [ i ] ) ; page_faults ++ ; indexes . push ( pages [ i ] ) ; } } else { if ( s . find ( pages [ i ] ) == s . end ( ) ) { int val = indexes . front ( ) ; indexes . pop ( ) ; s . erase ( val ) ; s . insert ( pages [ i ] ) ; indexes . push ( pages [ i ] ) ; page_faults ++ ; } } } return page_faults ; }
int nextFit ( int weight [ ] , int n , int c ) { int res = 0 , bin_rem = c ; for ( int i = 0 ; i < n ; i ++ ) { if ( weight [ i ] > bin_rem ) { res ++ ; bin_rem = c - weight [ i ] ; } else bin_rem -= weight [ i ] ; } return res ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
float circumferenceparallelogram ( float a , float b ) { return ( ( 2 * a ) + ( 2 * b ) ) ; }
void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { cout << ( 10 * rem ) / n ; rem = ( 10 * rem ) % n ; } }
string findString ( int n , int k ) { string res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
bool checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) swap ( arr [ i ] , arr [ i + 1 ] ) ; else return false ; } } return true ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
int getRemainder ( int num , int divisor ) { if ( divisor == 0 ) { cout << " Error : ▁ divisor ▁ can ' t ▁ be ▁ zero ▁ \n " ; return - 1 ; } if ( divisor < 0 ) divisor = - divisor ; if ( num < 0 ) num = - num ; int i = 1 ; int product = 0 ; while ( product <= num ) { product = divisor * i ; i ++ ; } return num - ( product - divisor ) ; }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int costToBalance ( string s ) { if ( s . length ( ) == 0 ) cout << 0 << endl ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) o ++ ; if ( s [ i ] == ' ) ' ) c ++ ; } if ( o != c ) return - 1 ; int a [ s . size ( ) ] ; if ( s [ 0 ] == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += abs ( a [ i ] ) ; } return ans ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int countSub ( int arr [ ] , int n ) { int count [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }
int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return - 1 ; stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' } ' && ! s . empty ( ) ) { if ( s . top ( ) == ' { ' ) s . pop ( ) ; else s . push ( expr [ i ] ) ; } else s . push ( expr [ i ] ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . top ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; }
bool printPairs ( int arr [ ] , int n , int k ) { bool isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " ▁ " ; isPairFound = true ; } } } return isPairFound ; }
int findRepeatFirst ( char * s ) { int p = - 1 , i , k ; int hash [ MAX_CHAR ] = { 0 } ; int pos [ MAX_CHAR ] ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { k = ( int ) s [ i ] ; if ( hash [ k ] == 0 ) { hash [ k ] ++ ; pos [ k ] = i ; } else if ( hash [ k ] == 1 ) hash [ k ] ++ ; } for ( i = 0 ; i < MAX_CHAR ; i ++ ) { if ( hash [ i ] == 2 ) { if ( p == - 1 ) p = pos [ i ] ; else if ( p > pos [ i ] ) p = pos [ i ] ; } } return p ; }
unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
int getSum ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) ; return sum ; }
int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
unsigned int factorial ( unsigned int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
void printDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
int findPlatform ( int arr [ ] , int dep [ ] , int n ) { sort ( arr , arr + n ) ; sort ( dep , dep + n ) ; int plat_needed = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat_needed ++ ; i ++ ; if ( plat_needed > result ) result = plat_needed ; } else { plat_needed -- ; j ++ ; } } return result ; }
bool modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; bool DP [ m ] ; memset ( DP , false , m ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool temp [ m ] ; memset ( temp , false , m ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
int sumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ] , sum = 0 ; memset ( prime , 0 , sizeof ( prime ) ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; }
int minJumps ( int a , int b , int d ) { int temp = a ; a = min ( a , b ) ; b = max ( temp , b ) ; if ( d >= b ) return ( d + b - 1 ) / b ; if ( d == 0 ) return 0 ; if ( d == a ) return 1 ; return 2 ; }
unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
void permutatedRows ( int mat [ ] [ MAX ] , int m , int n , int r ) { unordered_set < int > s ; for ( int j = 0 ; j < n ; j ++ ) s . insert ( mat [ r ] [ j ] ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) continue ; int j ; for ( j = 0 ; j < n ; j ++ ) if ( s . find ( mat [ i ] [ j ] ) == s . end ( ) ) break ; if ( j != n ) continue ; cout << i << " , ▁ " ; } }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; cout << num << " ▁ " ; } }
void ZigZag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int arr [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns and numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 and numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) cout << arr [ i ] [ j ] << " ▁ " ; cout << endl ; } }
int findElement ( int arr [ ] , int ranges [ ] [ 2 ] , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; }
string smallestNumber ( string num ) { int n = num . size ( ) ; int rightMin [ n ] , right ; rightMin [ n - 1 ] = - 1 ; right = n - 1 ; for ( int i = n - 2 ; i >= 1 ; i -- ) { if ( num [ i ] >= num [ right ] ) rightMin [ i ] = right ; else { if ( num [ i ] == num [ i + 1 ] ) { rightMin [ i ] = right ; } else { rightMin [ i ] = - 1 ; right = i ; } } } int small = - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( num [ i ] != '0' ) { if ( small == - 1 ) { if ( num [ i ] < num [ 0 ] ) small = i ; } else if ( num [ i ] <= num [ small ] ) small = i ; } if ( small != - 1 ) swap ( num [ 0 ] , num [ small ] ) ; else { for ( int i = 1 ; i < n ; i ++ ) { if ( rightMin [ i ] != - 1 && num [ i ] != num [ rightMin [ i ] ] ) { swap ( num [ i ] , num [ rightMin [ i ] ] ) ; break ; } } } return num ; }
int countPaths ( int maze [ ] [ C ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; }
void minMaxLengthWords ( string input , string & minWord , string & maxWord ) { int len = input . length ( ) ; int si = 0 , ei = 0 ; int min_length = len , min_start_index = 0 , max_length = 0 , max_start_index = 0 ; while ( ei <= len ) { if ( ei < len && input [ ei ] != ' ▁ ' ) ei ++ ; else { int curr_length = ei - si ; if ( curr_length < min_length ) { min_length = curr_length ; min_start_index = si ; } if ( curr_length > max_length ) { max_length = curr_length ; max_start_index = si ; } ei ++ ; si = ei ; } } minWord = input . substr ( min_start_index , min_length ) ; maxWord = input . substr ( max_start_index , max_length ) ; }
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
string sortString ( string str , int n ) { string new_str = " " ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str [ j ] == i ) new_str += str [ j ] ; return new_str ; }
int countTrees ( int n ) { int BT [ n + 1 ] ; memset ( BT , 0 , sizeof ( BT ) ) ; BT [ 0 ] = BT [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ; return BT [ n ] ; }
int getPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }
int check ( string str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int LCSubStr ( string X , string Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int len [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1 ; result = max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }
int removeConsecutiveSame ( vector < string > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v [ i ] . compare ( v [ i + 1 ] ) == 0 ) { v . erase ( v . begin ( ) + i ) ; v . erase ( v . begin ( ) + i ) ; if ( i > 0 ) i -- ; n = n - 2 ; } else i ++ ; } return v . size ( ) ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
bool isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ; return ( remainder == 0 ) ; }
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) invcount ++ ; } } } } return invcount ; }
void bin ( unsigned n ) { if ( n > 1 ) bin ( n / 2 ) ; cout << n % 2 ; }
int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return * min_element ( ar , ar + n ) ; int sum [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + ( * min_element ( sum + i - 4 , sum + i ) ) ; return * min_element ( sum + n - 4 , sum + n ) ; }
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
int minDist ( int arr [ ] , int n , int x , int y ) { int i = 0 ; int min_dist = INT_MAX ; int prev ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i ; break ; } } for ( ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) { min_dist = i - prev ; prev = i ; } else prev = i ; } } return min_dist ; }
int solve ( int a [ ] , int b [ ] , int n ) { int i ; long long int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = b [ i + 1 ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; }
void findString ( string str , int n , int k ) { if ( k == 0 ) { cout << str << endl ; return ; } string str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 [ i ] != ' a ' ) { str2 [ i ] = ' a ' ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == ' a ' ) { str2 [ i ] = ' b ' ; p ++ ; if ( p == k ) break ; } } cout << str2 << endl ; }
int findLongestRepeatingSubSeq ( string X , int m , int n ) { if ( dp [ m ] [ n ] != - 1 ) return dp [ m ] [ n ] ; if ( m == 0 || n == 0 ) return dp [ m ] [ n ] = 0 ; if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ; return dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) ; }
int productSubSeqCount ( vector < int > & arr , int k ) { int n = arr . size ( ) ; int dp [ k + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr [ j - 1 ] <= i && arr [ j - 1 ] > 0 ) dp [ i ] [ j ] += dp [ i / arr [ j - 1 ] ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int fix ( int A [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { if ( A [ i ] != - 1 && A [ i ] != i ) { int x = A [ i ] ; while ( A [ x ] != - 1 && A [ x ] != x ) { int y = A [ x ] ; A [ x ] = x ; x = y ; } A [ x ] = x ; if ( A [ i ] != i ) { A [ i ] = - 1 ; } } } }
ll calculate ( ll a [ ] , ll n ) { sort ( a , a + n ) ; vector < ll > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( a [ i ] + a [ j ] ) ; ll mini = * min_element ( s . begin ( ) , s . end ( ) ) ; ll maxi = * max_element ( s . begin ( ) , s . end ( ) ) ; return abs ( maxi - mini ) ; }
float sumOfSeries ( int n ) { return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
void sortInWave ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( & arr [ i ] , & arr [ i + 1 ] ) ; }
void search ( int * arr , int low , int high ) { if ( low > high ) return ; if ( low == high ) { printf ( " The ▁ required ▁ element ▁ is ▁ % d ▁ " , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }
bool check ( string str ) { int n = str . length ( ) ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
long int stirlingFactorial ( int n ) { if ( n == 1 ) return 1 ; long int z ; float e = 2.71 ; z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ) , n ) ; return z ; }
bool checkCount ( int arr [ ] , int n , int k ) { int count ; for ( int i = 0 ; i < n ; i ++ ) { count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) count ++ ; if ( count > 2 * k ) return false ; } } return true ; }
bool areElementsContiguous ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; int min = * min_element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
int lcs ( string & X , string & Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ 2 ] [ n + 1 ] ; bool bi ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { deque < int > Di ; int i ; for ( i = 0 ; i < k ; i ++ ) if ( arr [ i ] < 0 ) Di . push_back ( i ) ; for ( ; i < n ; i ++ ) { if ( ! Di . empty ( ) ) cout << arr [ Di . front ( ) ] << " ▁ " ; else cout << "0" << " ▁ " ; while ( ( ! Di . empty ( ) ) && Di . front ( ) < ( i - k + 1 ) ) Di . pop_front ( ) ; if ( arr [ i ] < 0 ) Di . push_back ( i ) ; } if ( ! Di . empty ( ) ) cout << arr [ Di . front ( ) ] << " ▁ " ; else cout << "0" << " ▁ " ; }
int findRoot ( pair < int , int > arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) root += ( arr [ i ] . first - arr [ i ] . second ) ; return root ; }
int findArea ( int arr [ ] , int n ) { unordered_set < int > s ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }
void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
int FindMaxProduct ( int arr [ ] [ n ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } } } return max ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && floor ( root2 ) == root2 ) return true ; return false ; }
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
int maxOnesIndex ( bool arr [ ] , int n ) { int max_count = 0 ; int max_index ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
void leafNode ( int preorder [ ] , int n ) { stack < int > s ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { bool found = false ; if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] ) ; else { while ( ! s . empty ( ) ) { if ( preorder [ j ] > s . top ( ) ) { s . pop ( ) ; found = true ; } else break ; } } if ( found ) cout << preorder [ i ] << " ▁ " ; } cout << preorder [ n - 1 ] ; }
bool isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( arr2 [ i ] == arr1 [ j ] ) break ; } if ( j == m ) return 0 ; } return 1 ; }
long multiplyBySeven ( long n ) { return ( ( n << 3 ) - n ) ; }
int unboundedKnapsack ( int W , int n , int val [ ] , int wt [ ] ) { int dp [ W + 1 ] ; memset ( dp , 0 , sizeof dp ) ; int ans = 0 ; for ( int i = 0 ; i <= W ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( wt [ j ] <= i ) dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; return dp [ W ] ; }
void alternateSubarray ( bool arr [ ] , int n ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == 0 ) { while ( count ) cout << count -- << " ▁ " ; } ++ count ; prev = arr [ i ] ; } while ( count ) cout << count -- << " ▁ " ; }
int countkDist ( string str , int k ) { int n = str . length ( ) ; int res = 0 ; int cnt [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; if ( dist_count > k ) break ; } } return res ; }
void modularInverse ( int n , int prime ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; for ( int i = 1 ; i <= n ; i ++ ) cout << dp [ i ] << ' ▁ ' ; }
int countWays ( int n ) { int DP [ n + 1 ] ; DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ; DP [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ; return DP [ n ] ; }
int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
int countPattern ( string str ) { int len = str . size ( ) ; bool oneSeen = 0 ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' && oneSeen == 1 ) if ( str [ i - 1 ] == '0' ) count ++ ; if ( str [ i ] == '1' && oneSeen == 0 ) { oneSeen = 1 ; continue ; } if ( str [ i ] != '0' && str [ i ] != '1' ) oneSeen = 0 ; } return count ; }
int maxRemoval ( int arr [ ] , int n ) { int count = 0 ; int cummulative_sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= cummulative_sum ) { count ++ ; cummulative_sum += arr [ i ] ; } } return count ; }
string LexicographicalMaxString ( string str ) { string mx = " " ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) mx = max ( mx , str . substr ( i ) ) ; return mx ; }
